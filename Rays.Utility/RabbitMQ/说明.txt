1.使用EasyNetQ操作RabbitMQ
2.会创建两张表。一张发布表，一张订阅表，用于保存发布/订阅记录。当有失败的记录时，用补偿API再次发布/订阅。当然还要考虑消息重复消费的问题。并需要对成功的数据做定期清理，避免数据量过大
影响性能。其实是参考的CAP
3.后期考虑：高并发情况。我们小程序大部分都是查询接口，可以用Redis缓存起来，当然与用户有关的数据会出现变化，例如，用户书籍列表。用户添加/删除书籍时，原Redis就需要更新。那么这种情况下
就可以在用户添加/删除书籍操作下，用RabbitMQ实现异步削峰，发布添加/删除，订阅并处理，然后更新Redis。或简单一点，添加/删除操作结束后，使用RabbitMQ实现Redis更新。
为了提高Redis一致性，毕竟需要考虑Rabbit没有失败的情况，那么可以给Redis保存的数据加上状态。当发生添加/删除操作时，变为不可以unable状态，更新成功之后变成可用状态able。如果Redis处于
able状态，那么直接用，如果不是，需要查询数据库。
